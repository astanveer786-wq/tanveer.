<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Speed Racer Pro - Ultimate Racing Experience</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            user-select: none;
        }

        #gameContainer {
            width: 100vw;
            height: 100vh;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #gameCanvas {
            border: 2px solid #333;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
        }

        /* Menu Styles */
        .menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.5s ease;
        }

        .menu.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .menu h1 {
            font-size: 4em;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .menuButton {
            background: linear-gradient(45deg, #00ffff, #0080ff);
            border: none;
            color: #000;
            padding: 15px 40px;
            font-size: 1.2em;
            font-weight: bold;
            margin: 10px;
            cursor: pointer;
            border-radius: 30px;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .menuButton:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 20px rgba(0, 255, 255, 0.4);
        }

        .menuButton:active {
            transform: translateY(-1px);
        }

        /* HUD Styles */
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
            z-index: 100;
        }

        .hudPanel {
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #00ffff;
            backdrop-filter: blur(10px);
        }

        .speedometer {
            font-size: 2em;
            font-weight: bold;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
        }

        .score {
            font-size: 1.5em;
            color: #ffff00;
        }

        .distance {
            font-size: 1.2em;
            color: #00ff00;
        }

        /* Minimap */
        #minimap {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ffff;
            border-radius: 10px;
            overflow: hidden;
        }

        /* Power-up indicators */
        .powerupIndicator {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            gap: 10px;
        }

        .powerupSlot {
            width: 60px;
            height: 60px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #666;
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2em;
            transition: all 0.3s ease;
        }

        .powerupSlot.active {
            border-color: #00ffff;
            box-shadow: 0 0 20px #00ffff;
            animation: powerupPulse 1s infinite;
        }

        @keyframes powerupPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        /* Game Over Screen */
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border-radius: 20px;
            border: 3px solid #ff0000;
            text-align: center;
            display: none;
            z-index: 1000;
        }

        #gameOver h2 {
            font-size: 3em;
            color: #ff0000;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #ff0000;
        }

        .finalStats {
            font-size: 1.2em;
            margin: 20px 0;
            line-height: 1.8;
        }

        /* Loading Screen */
        #loadingScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .loadingBar {
            width: 400px;
            height: 30px;
            background: #333;
            border-radius: 15px;
            overflow: hidden;
            margin-top: 20px;
        }

        .loadingProgress {
            height: 100%;
            background: linear-gradient(90deg, #00ffff, #0080ff);
            width: 0%;
            transition: width 0.3s ease;
        }

        /* Achievement Notification */
        .achievement {
            position: absolute;
            top: 100px;
            right: -400px;
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            color: #000;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(255, 215, 0, 0.5);
            transition: right 0.5s ease;
            z-index: 1000;
        }

        .achievement.show {
            right: 20px;
        }

        .achievement h3 {
            font-size: 1.2em;
            margin-bottom: 5px;
        }

        /* Settings Menu */
        .settingsMenu {
            background: rgba(0, 0, 0, 0.95);
            padding: 30px;
            border-radius: 20px;
            border: 2px solid #00ffff;
            max-width: 500px;
            width: 90%;
        }

        .settingsMenu h2 {
            text-align: center;
            margin-bottom: 30px;
            color: #00ffff;
        }

        .settingItem {
            margin: 20px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .slider {
            width: 200px;
            height: 5px;
            background: #333;
            outline: none;
            opacity: 0.7;
            transition: opacity 0.2s;
            border-radius: 5px;
        }

        .slider:hover {
            opacity: 1;
        }

        .slider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            background: #00ffff;
            cursor: pointer;
            border-radius: 50%;
        }

        /* Car Selection */
        .carSelection {
            display: flex;
            gap: 20px;
            margin: 20px 0;
            justify-content: center;
            flex-wrap: wrap;
        }

        .carOption {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #666;
            padding: 20px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .carOption:hover {
            border-color: #00ffff;
            transform: translateY(-5px);
        }

        .carOption.selected {
            border-color: #00ffff;
            background: rgba(0, 255, 255, 0.2);
        }

        .carPreview {
            width: 80px;
            height: 40px;
            margin: 10px auto;
            background: #ff0000;
            border-radius: 5px;
        }

        /* Weather Effects */
        .weatherOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
        }

        .rain {
            background-image: 
                linear-gradient(transparent, rgba(255, 255, 255, 0.1) 50%, transparent);
            background-size: 2px 100px;
            animation: rain 0.3s linear infinite;
        }

        @keyframes rain {
            to { transform: translateY(100px); }
        }

        .fog {
            background: radial-gradient(circle, transparent 30%, rgba(255, 255, 255, 0.3) 100%);
        }

        /* Pause Menu */
        #pauseMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border-radius: 20px;
            border: 2px solid #00ffff;
            display: none;
            z-index: 1000;
        }

        #pauseMenu h2 {
            text-align: center;
            margin-bottom: 30px;
            color: #00ffff;
        }

        /* Tutorial */
        .tutorial {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #ffff00;
            text-align: center;
            z-index: 100;
        }

        .tutorial h3 {
            color: #ffff00;
            margin-bottom: 10px;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .menu h1 {
                font-size: 2.5em;
            }
            
            .menuButton {
                padding: 12px 30px;
                font-size: 1em;
            }
            
            #minimap {
                width: 150px;
                height: 100px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <!-- HUD -->
        <div id="hud">
            <div class="hudPanel">
                <div class="speedometer">0 km/h</div>
                <div class="distance">Distance: 0m</div>
            </div>
            <div class="hudPanel">
                <div class="score">Score: 0</div>
                <div id="gameMode">Mode: Endless</div>
            </div>
        </div>
        
        <!-- Power-up Indicators -->
        <div class="powerupIndicator">
            <div class="powerupSlot" id="powerup1"></div>
            <div class="powerupSlot" id="powerup2"></div>
            <div class="powerupSlot" id="powerup3"></div>
        </div>
        
        <!-- Minimap -->
        <canvas id="minimap"></canvas>
        
        <!-- Weather Overlay -->
        <div class="weatherOverlay" id="weatherOverlay"></div>
        
        <!-- Main Menu -->
        <div class="menu" id="mainMenu">
            <h1>Speed Racer Pro</h1>
            <button class="menuButton" onclick="showGameModeSelection()">Play</button>
            <button class="menuButton" onclick="showCarSelection()">Garage</button>
            <button class="menuButton" onclick="showLeaderboard()">Leaderboard</button>
            <button class="menuButton" onclick="showSettings()">Settings</button>
            <button class="menuButton" onclick="showTutorial()">Tutorial</button>
        </div>
        
        <!-- Game Mode Selection -->
        <div class="menu hidden" id="gameModeMenu">
            <h1>Select Game Mode</h1>
            <button class="menuButton" onclick="startGame('endless')">Endless Mode</button>
            <button class="menuButton" onclick="startGame('timetrial')">Time Trial</button>
            <button class="menuButton" onclick="startGame('levels')">Level Mode</button>
            <button class="menuButton" onclick="startGame('police')">Police Chase</button>
            <button class="menuButton" onclick="backToMenu()">Back</button>
        </div>
        
        <!-- Car Selection -->
        <div class="menu hidden" id="carSelectionMenu">
            <h1>Choose Your Car</h1>
            <div class="carSelection" id="carOptions"></div>
            <button class="menuButton" onclick="backToMenu()">Back</button>
        </div>
        
        <!-- Settings Menu -->
        <div class="menu hidden" id="settingsMenu">
            <div class="settingsMenu">
                <h2>Settings</h2>
                <div class="settingItem">
                    <span>Sound Volume</span>
                    <input type="range" class="slider" id="soundVolume" min="0" max="100" value="50">
                </div>
                <div class="settingItem">
                    <span>Music Volume</span>
                    <input type="range" class="slider" id="musicVolume" min="0" max="100" value="50">
                </div>
                <div class="settingItem">
                    <span>Difficulty</span>
                    <select id="difficulty" style="padding: 5px; background: #333; color: #fff; border: 1px solid #666;">
                        <option value="easy">Easy</option>
                        <option value="normal" selected>Normal</option>
                        <option value="hard">Hard</option>
                        <option value="extreme">Extreme</option>
                    </select>
                </div>
                <div class="settingItem">
                    <span>Graphics Quality</span>
                    <select id="graphics" style="padding: 5px; background: #333; color: #fff; border: 1px solid #666;">
                        <option value="low">Low</option>
                        <option value="medium" selected>Medium</option>
                        <option value="high">High</option>
                    </select>
                </div>
                <button class="menuButton" onclick="saveSettings()">Save</button>
                <button class="menuButton" onclick="backToMenu()">Back</button>
            </div>
        </div>
        
        <!-- Pause Menu -->
        <div id="pauseMenu">
            <h2>Paused</h2>
            <button class="menuButton" onclick="resumeGame()">Resume</button>
            <button class="menuButton" onclick="restartGame()">Restart</button>
            <button class="menuButton" onclick="backToMenu()">Main Menu</button>
        </div>
        
        <!-- Game Over Screen -->
        <div id="gameOver">
            <h2>Game Over!</h2>
            <div class="finalStats" id="finalStats"></div>
            <button class="menuButton" onclick="restartGame()">Play Again</button>
            <button class="menuButton" onclick="backToMenu()">Main Menu</button>
        </div>
        
        <!-- Achievement Notification -->
        <div class="achievement" id="achievement">
            <h3>Achievement Unlocked!</h3>
            <p id="achievementText"></p>
        </div>
        
        <!-- Tutorial -->
        <div class="tutorial" id="tutorial" style="display: none;">
            <h3>How to Play</h3>
            <p>Use Arrow Keys or WASD to control your car</p>
            <p>Avoid obstacles and collect power-ups</p>
            <p>Press ESC to pause</p>
        </div>
        
        <!-- Loading Screen -->
        <div id="loadingScreen">
            <h1>Loading...</h1>
            <div class="loadingBar">
                <div class="loadingProgress" id="loadingProgress"></div>
            </div>
        </div>
    </div>

    <script>
        // Game Configuration
        const CONFIG = {
            canvasWidth: 800,
            canvasHeight: 600,
            roadWidth: 400,
            laneWidth: 100,
            maxSpeed: 300,
            acceleration: 0.5,
            deceleration: 0.3,
            turnSpeed: 5,
            enemySpawnRate: 60,
            powerupSpawnRate: 180,
            obstacleSpawnRate: 120,
            particleCount: 100,
            minimapScale: 0.25
        };

        // Game State
        let gameState = {
            isPlaying: false,
            isPaused: false,
            score: 0,
            distance: 0,
            speed: 0,
            currentMode: 'endless',
            level: 1,
            time: 0,
            weather: 'clear',
            dayNightCycle: 0,
            difficulty: 'normal',
            graphicsQuality: 'medium',
            soundVolume: 50,
            musicVolume: 50,
            selectedCar: 0,
            achievements: [],
            highScores: {
                endless: 0,
                timetrial: 0,
                levels: 0,
                police: 0
            }
        };

        // Canvas Setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const minimap = document.getElementById('minimap');
        const minimapCtx = minimap.getContext('2d');

        canvas.width = CONFIG.canvasWidth;
        canvas.height = CONFIG.canvasHeight;
        minimap.width = 200;
        minimap.height = 150;

        // Input Handling
        const keys = {};
        let touchStartX = 0;
        let touchStartY = 0;

        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            
            if (e.key === 'Escape' && gameState.isPlaying) {
                togglePause();
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        // Touch Controls
        canvas.addEventListener('touchstart', (e) => {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        });

        canvas.addEventListener('touchmove', (e) => {
            if (!gameState.isPlaying || gameState.isPaused) return;
            
            const touchX = e.touches[0].clientX;
            const touchY = e.touches[0].clientY;
            const deltaX = touchX - touchStartX;
            const deltaY = touchY - touchStartY;
            
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                if (deltaX > 50) {
                    keys['arrowright'] = true;
                    keys['arrowleft'] = false;
                } else if (deltaX < -50) {
                    keys['arrowleft'] = true;
                    keys['arrowright'] = false;
                }
            } else {
                if (deltaY > 50) {
                    keys['arrowdown'] = true;
                    keys['arrowup'] = false;
                } else if (deltaY < -50) {
                    keys['arrowup'] = true;
                    keys['arrowdown'] = false;
                }
            }
        });

        canvas.addEventListener('touchend', () => {
            keys['arrowleft'] = false;
            keys['arrowright'] = false;
            keys['arrowup'] = false;
            keys['arrowdown'] = false;
        });

        // Car Class
        class Car {
            constructor(x, y, width, height, color, type = 'player') {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.color = color;
                this.type = type;
                this.speed = 0;
                this.maxSpeed = type === 'player' ? CONFIG.maxSpeed : 150;
                this.acceleration = type === 'player' ? CONFIG.acceleration : 0.3;
                this.deceleration = type === 'player' ? CONFIG.deceleration : 0.2;
                this.turnSpeed = CONFIG.turnSpeed;
                this.lane = 1;
                this.targetX = x;
                this.health = 100;
                this.shield = false;
                this.boost = false;
                this.magnet = false;
                this.angle = 0;
                this.drift = 0;
                this.exhaustParticles = [];
                this.sparks = [];
            }

            update() {
                // Handle input
                if (this.type === 'player') {
                    if (keys['arrowup'] || keys['w']) {
                        this.speed = Math.min(this.speed + this.acceleration, this.maxSpeed);
                    } else if (keys['arrowdown'] || keys['s']) {
                        this.speed = Math.max(this.speed - this.deceleration * 2, 0);
                    } else {
                        this.speed = Math.max(this.speed - this.deceleration, 0);
                    }

                    if (keys['arrowleft'] || keys['a']) {
                        this.x -= this.turnSpeed;
                        this.drift = Math.max(this.drift - 0.5, -10);
                        this.angle = Math.max(this.angle - 0.1, -0.3);
                    } else if (keys['arrowright'] || keys['d']) {
                        this.x += this.turnSpeed;
                        this.drift = Math.min(this.drift + 0.5, 10);
                        this.angle = Math.min(this.angle + 0.1, 0.3);
                    } else {
                        this.drift *= 0.9;
                        this.angle *= 0.9;
                    }

                    // Apply boost
                    if (this.boost) {
                        this.maxSpeed = CONFIG.maxSpeed * 1.5;
                    } else {
                        this.maxSpeed = CONFIG.maxSpeed;
                    }
                }

                // Keep car on road
                const roadLeft = (canvas.width - CONFIG.roadWidth) / 2;
                const roadRight = roadLeft + CONFIG.roadWidth;
                this.x = Math.max(roadLeft + this.width / 2, Math.min(roadRight - this.width / 2, this.x));

                // Update lane
                this.lane = Math.floor((this.x - roadLeft) / CONFIG.laneWidth);

                // Update exhaust particles
                if (this.speed > 50 && Math.random() < 0.8) {
                    this.exhaustParticles.push({
                        x: this.x - this.width / 2 + Math.random() * this.width,
                        y: this.y + this.height / 2,
                        vx: (Math.random() - 0.5) * 2,
                        vy: Math.random() * 2 + 1,
                        life: 1,
                        color: this.boost ? '#00ffff' : '#666'
                    });
                }

                // Update particles
                this.exhaustParticles = this.exhaustParticles.filter(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life -= 0.02;
                    return p.life > 0;
                });

                // Update sparks
                this.sparks = this.sparks.filter(s => {
                    s.x += s.vx;
                    s.y += s.vy;
                    s.vy += 0.5;
                    s.life -= 0.05;
                    return s.life > 0;
                });
            }

            draw(ctx) {
                ctx.save();
                
                // Apply transformations
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                ctx.translate(this.drift, 0);

                // Draw shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(-this.width / 2 + 5, -this.height / 2 + 5, this.width, this.height);

                // Draw car body
                ctx.fillStyle = this.color;
                ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);

                // Draw car details
                ctx.fillStyle = '#333';
                ctx.fillRect(-this.width / 2 + 5, -this.height / 2 + 5, this.width - 10, 10);
                ctx.fillRect(-this.width / 2 + 5, this.height / 2 - 15, this.width - 10, 10);

                // Draw windows
                ctx.fillStyle = 'rgba(100, 150, 200, 0.8)';
                ctx.fillRect(-this.width / 2 + 10, -this.height / 2 + 15, this.width - 20, 15);

                // Draw headlights
                if (gameState.dayNightCycle > 0.5 || gameState.weather === 'night') {
                    ctx.fillStyle = 'rgba(255, 255, 200, 0.8)';
                    ctx.beginPath();
                    ctx.moveTo(-this.width / 2, -this.height / 2);
                    ctx.lineTo(-this.width / 2 - 20, -this.height / 2 - 30);
                    ctx.lineTo(-this.width / 2 + 20, -this.height / 2 - 30);
                    ctx.closePath();
                    ctx.fill();

                    ctx.beginPath();
                    ctx.moveTo(this.width / 2, -this.height / 2);
                    ctx.lineTo(this.width / 2 + 20, -this.height / 2 - 30);
                    ctx.lineTo(this.width / 2 - 20, -this.height / 2 - 30);
                    ctx.closePath();
                    ctx.fill();
                }

                // Draw shield
                if (this.shield) {
                    ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.width, 0, Math.PI * 2);
                    ctx.stroke();
                }

                ctx.restore();

                // Draw particles
                this.exhaustParticles.forEach(p => {
                    ctx.fillStyle = p.color + Math.floor(p.life * 255).toString(16).padStart(2, '0');
                    ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
                });

                this.sparks.forEach(s => {
                    ctx.fillStyle = `rgba(255, ${Math.floor(s.life * 255)}, 0, ${s.life})`;
                    ctx.fillRect(s.x - 1, s.y - 1, 2, 2);
                });
            }

            addSparks() {
                for (let i = 0; i < 10; i++) {
                    this.sparks.push({
                        x: this.x + (Math.random() - 0.5) * this.width,
                        y: this.y + (Math.random() - 0.5) * this.height,
                        vx: (Math.random() - 0.5) * 10,
                        vy: -Math.random() * 5,
                        life: 1
                    });
                }
            }
        }

        // Enemy Car Class
        class EnemyCar extends Car {
            constructor(x, y, lane) {
                const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff'];
                super(x, y, 60, 100, colors[Math.floor(Math.random() * colors.length)], 'enemy');
                this.lane = lane;
                this.targetLane = lane;
                this.changeLaneTimer = 0;
                this.aggressive = Math.random() < 0.3;
                this.police = Math.random() < 0.1 && gameState.currentMode === 'police';
                
                if (this.police) {
                    this.color = '#0000ff';
                    this.maxSpeed = 200;
                    this.aggressive = true;
                }
            }

            update(player) {
                // AI behavior
                if (this.changeLaneTimer <= 0) {
                    if (Math.random() < 0.02 || this.shouldChangeLane(player)) {
                        this.targetLane = Math.floor(Math.random() * 4);
                        this.changeLaneTimer = 60;
                    }
                } else {
                    this.changeLaneTimer--;
                }

                // Move towards target lane
                const targetX = (canvas.width - CONFIG.roadWidth) / 2 + this.targetLane * CONFIG.laneWidth + CONFIG.laneWidth / 2;
                const diff = targetX - this.x;
                
                if (Math.abs(diff) > 5) {
                    this.x += Math.sign(diff) * 3;
                }

                // Speed adjustment
                if (this.police) {
                    this.speed = Math.min(this.speed + this.acceleration * 1.5, this.maxSpeed);
                } else if (this.aggressive && player) {
                    const distanceToPlayer = Math.abs(this.y - player.y);
                    if (distanceToPlayer < 200 && this.y > player.y) {
                        this.speed = Math.min(this.speed + this.acceleration * 1.2, this.maxSpeed);
                    } else {
                        this.speed = Math.max(this.speed - this.deceleration, 50);
                    }
                } else {
                    this.speed = 80 + Math.random() * 40;
                }

                // Update position
                this.y += this.speed * 0.1;

                // Update particles
                if (this.speed > 50 && Math.random() < 0.6) {
                    this.exhaustParticles.push({
                        x: this.x - this.width / 2 + Math.random() * this.width,
                        y: this.y - this.height / 2,
                        vx: (Math.random() - 0.5) * 2,
                        vy: -Math.random() * 2 - 1,
                        life: 1,
                        color: '#666'
                    });
                }

                this.exhaustParticles = this.exhaustParticles.filter(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life -= 0.02;
                    return p.life > 0;
                });
            }

            shouldChangeLane(player) {
                if (!player) return false;
                
                const sameLane = this.lane === player.lane;
                const behindPlayer = this.y > player.y;
                const closeToPlayer = Math.abs(this.y - player.y) < 150;
                
                return sameLane && behindPlayer && closeToPlayer;
            }

            draw(ctx) {
                super.draw(ctx);
                
                // Draw police lights
                if (this.police) {
                    ctx.save();
                    ctx.translate(this.x, this.y - this.height / 2);
                    
                    const time = Date.now() / 200;
                    ctx.fillStyle = time % 2 < 1 ? '#ff0000' : '#0000ff';
                    ctx.fillRect(-10, -5, 8, 5);
                    ctx.fillRect(2, -5, 8, 5);
                    
                    ctx.restore();
                }
            }
        }

        // Power-up Class
        class PowerUp {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.width = 40;
                this.height = 40;
                this.collected = false;
                this.animation = 0;
                
                this.colors = {
                    boost: '#ff0000',
                    shield: '#00ffff',
                    magnet: '#ffff00',
                    slow: '#00ff00',
                    points: '#ff00ff'
                };
                
                this.icons = {
                    boost: '⚡',
                    shield: '🛡️',
                    magnet: '🧲',
                    slow: '❄️',
                    points: '💎'
                };
            }

            update() {
                this.animation += 0.1;
                this.y += 2;
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.animation);
                
                // Glow effect
                ctx.shadowBlur = 20;
                ctx.shadowColor = this.colors[this.type];
                
                // Background
                ctx.fillStyle = this.colors[this.type];
                ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                
                // Icon
                ctx.fillStyle = '#fff';
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.icons[this.type], 0, 0);
                
                ctx.restore();
            }
        }

        // Obstacle Class
        class Obstacle {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.width = type === 'cone' ? 20 : 60;
                this.height = type === 'cone' ? 30 : 20;
                this.hit = false;
            }

            update() {
                this.y += 2;
            }

            draw(ctx) {
                ctx.save();
                
                if (this.type === 'cone') {
                    // Draw traffic cone
                    ctx.fillStyle = '#ff8800';
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y - this.height / 2);
                    ctx.lineTo(this.x - this.width / 2, this.y + this.height / 2);
                    ctx.lineTo(this.x + this.width / 2, this.y + this.height / 2);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(this.x - 2, this.y - 5, 4, 10);
                } else if (this.type === 'barrier') {
                    // Draw barrier
                    ctx.fillStyle = '#ffcc00';
                    ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
                    
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < this.width; i += 10) {
                        ctx.beginPath();
                        ctx.moveTo(this.x - this.width / 2 + i, this.y - this.height / 2);
                        ctx.lineTo(this.x - this.width / 2 + i, this.y + this.height / 2);
                        ctx.stroke();
                    }
                }
                
                ctx.restore();
            }
        }

        // Particle System
        class ParticleSystem {
            constructor() {
                this.particles = [];
            }

            addParticle(x, y, vx, vy, color, life) {
                this.particles.push({
                    x, y, vx, vy, color, life, maxLife: life
                });
            }

            update() {
                this.particles = this.particles.filter(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.2;
                    p.life--;
                    return p.life > 0;
                });
            }

            draw(ctx) {
                this.particles.forEach(p => {
                    const alpha = p.life / p.maxLife;
                    ctx.fillStyle = p.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
                    ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
                });
            }

            createExplosion(x, y, color = '#ff6600') {
                for (let i = 0; i < 30; i++) {
                    const angle = (Math.PI * 2 * i) / 30;
                    const speed = Math.random() * 5 + 2;
                    this.addParticle(
                        x, y,
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed,
                        color,
                        30
                    );
                }
            }
        }

        // Road Class
        class Road {
            constructor() {
                this.lines = [];
                this.lineHeight = 100;
                this.lineSpeed = 0;
                this.offset = 0;
                
                // Initialize road lines
                for (let i = 0; i < canvas.height / this.lineHeight + 2; i++) {
                    this.lines.push(i * this.lineHeight);
                }
            }

            update(speed) {
                this.lineSpeed = speed * 0.1;
                this.offset += this.lineSpeed;
                
                if (this.offset >= this.lineHeight) {
                    this.offset -= this.lineHeight;
                }
            }

            draw(ctx) {
                const roadLeft = (canvas.width - CONFIG.roadWidth) / 2;
                const roadRight = roadLeft + CONFIG.roadWidth;
                
                // Draw road
                ctx.fillStyle = '#333';
                ctx.fillRect(roadLeft, 0, CONFIG.roadWidth, canvas.height);
                
                // Draw road edges
                ctx.fillStyle = '#fff';
                ctx.fillRect(roadLeft - 10, 0, 10, canvas.height);
                ctx.fillRect(roadRight, 0, 10, canvas.height);
                
                // Draw lane lines
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 5;
                ctx.setLineDash([40, 20]);
                
                for (let i = 0; i < 3; i++) {
                    const x = roadLeft + (i + 1) * CONFIG.laneWidth;
                    ctx.beginPath();
                    ctx.moveTo(x, -this.offset);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                }
                
                ctx.setLineDash([]);
            }
        }

        // Background Class
        class Background {
            constructor() {
                this.mountains = [];
                this.trees = [];
                this.clouds = [];
                
                // Generate background elements
                for (let i = 0; i < 5; i++) {
                    this.mountains.push({
                        x: Math.random() * canvas.width,
                        y: canvas.height * 0.3 + Math.random() * 100,
                        width: 200 + Math.random() * 200,
                        height: 150 + Math.random() * 100,
                        speed: 0.1 + Math.random() * 0.2
                    });
                }
                
                for (let i = 0; i < 20; i++) {
                    this.trees.push({
                        x: Math.random() * canvas.width,
                        y: canvas.height * 0.5 + Math.random() * 200,
                        size: 20 + Math.random() * 30,
                        speed: 0.5 + Math.random() * 0.5
                    });
                }
                
                for (let i = 0; i < 10; i++) {
                    this.clouds.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height * 0.4,
                        size: 50 + Math.random() * 50,
                        speed: 0.05 + Math.random() * 0.1
                    });
                }
            }

            update(speed) {
                const parallaxFactor = speed * 0.01;
                
                // Update mountains
                this.mountains.forEach(m => {
                    m.x -= m.speed * parallaxFactor;
                    if (m.x + m.width < 0) {
                        m.x = canvas.width;
                    }
                });
                
                // Update trees
                this.trees.forEach(t => {
                    t.x -= t.speed * parallaxFactor;
                    if (t.x + t.size < 0) {
                        t.x = canvas.width;
                        t.y = canvas.height * 0.5 + Math.random() * 200;
                    }
                });
                
                // Update clouds
                this.clouds.forEach(c => {
                    c.x -= c.speed * parallaxFactor * 0.5;
                    if (c.x + c.size < 0) {
                        c.x = canvas.width;
                        c.y = Math.random() * canvas.height * 0.4;
                    }
                });
            }

            draw(ctx) {
                // Sky gradient based on time
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                
                if (gameState.dayNightCycle < 0.25) {
                    // Day
                    gradient.addColorStop(0, '#87CEEB');
                    gradient.addColorStop(1, '#98D8E8');
                } else if (gameState.dayNightCycle < 0.5) {
                    // Sunset
                    gradient.addColorStop(0, '#FF6B6B');
                    gradient.addColorStop(0.5, '#FFE66D');
                    gradient.addColorStop(1, '#FF8E53');
                } else if (gameState.dayNightCycle < 0.75) {
                    // Night
                    gradient.addColorStop(0, '#0C1445');
                    gradient.addColorStop(1, '#183059');
                } else {
                    // Dawn
                    gradient.addColorStop(0, '#FF6B6B');
                    gradient.addColorStop(0.5, '#4ECDC4');
                    gradient.addColorStop(1, '#556270');
                }
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw sun/moon
                const celestialY = canvas.height * 0.2 + Math.sin(gameState.dayNightCycle * Math.PI * 2) * 100;
                const celestialX = canvas.width * 0.8;
                
                if (gameState.dayNightCycle < 0.5) {
                    // Sun
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(celestialX, celestialY, 40, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Sun rays
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 3;
                    for (let i = 0; i < 12; i++) {
                        const angle = (i / 12) * Math.PI * 2;
                        ctx.beginPath();
                        ctx.moveTo(
                            celestialX + Math.cos(angle) * 50,
                            celestialY + Math.sin(angle) * 50
                        );
                        ctx.lineTo(
                            celestialX + Math.cos(angle) * 70,
                            celestialY + Math.sin(angle) * 70
                        );
                        ctx.stroke();
                    }
                } else {
                    // Moon
                    ctx.fillStyle = '#F0F0F0';
                    ctx.beginPath();
                    ctx.arc(celestialX, celestialY, 35, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Moon craters
                    ctx.fillStyle = '#D0D0D0';
                    ctx.beginPath();
                    ctx.arc(celestialX - 10, celestialY - 5, 8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(celestialX + 15, celestialY + 10, 5, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Draw clouds
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                this.clouds.forEach(c => {
                    ctx.beginPath();
                    ctx.arc(c.x, c.y, c.size * 0.5, 0, Math.PI * 2);
                    ctx.arc(c.x + c.size * 0.3, c.y, c.size * 0.4, 0, Math.PI * 2);
                    ctx.arc(c.x - c.size * 0.3, c.y, c.size * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                // Draw mountains
                this.mountains.forEach(m => {
                    ctx.fillStyle = '#4a5568';
                    ctx.beginPath();
                    ctx.moveTo(m.x - m.width / 2, m.y);
                    ctx.lineTo(m.x, m.y - m.height);
                    ctx.lineTo(m.x + m.width / 2, m.y);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Snow caps
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.moveTo(m.x - m.width * 0.2, m.y - m.height * 0.7);
                    ctx.lineTo(m.x, m.y - m.height);
                    ctx.lineTo(m.x + m.width * 0.2, m.y - m.height * 0.7);
                    ctx.closePath();
                    ctx.fill();
                });
                
                // Draw trees
                this.trees.forEach(t => {
                    // Tree trunk
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(t.x - t.size * 0.1, t.y, t.size * 0.2, t.size * 0.5);
                    
                    // Tree foliage
                    ctx.fillStyle = '#228B22';
                    ctx.beginPath();
                    ctx.moveTo(t.x, t.y - t.size * 0.5);
                    ctx.lineTo(t.x - t.size * 0.4, t.y);
                    ctx.lineTo(t.x + t.size * 0.4, t.y);
                    ctx.closePath();
                    ctx.fill();
                });
            }
        }

        // Game Objects
        let player;
        let enemies = [];
        let powerups = [];
        let obstacles = [];
        let road;
        let background;
        let particleSystem;
        let frameCount = 0;
        let lastTime = 0;

        // Car Types
        const carTypes = [
            { name: 'Speedster', color: '#ff0000', speed: 1.2, handling: 1.0 },
            { name: 'Cruiser', color: '#0000ff', speed: 1.0, handling: 1.2 },
            { name: 'Racer', color: '#00ff00', speed: 1.1, handling: 1.1 },
            { name: 'Beast', color: '#ff00ff', speed: 1.3, handling: 0.9 },
            { name: 'Phantom', color: '#00ffff', speed: 1.15, handling: 1.15 }
        ];

        // Initialize Game
        function initGame() {
            // Create game objects
            road = new Road();
            background = new Background();
            particleSystem = new ParticleSystem();
            
            // Create player car
            const carType = carTypes[gameState.selectedCar];
            player = new Car(
                canvas.width / 2,
                canvas.height - 150,
                60,
                100,
                carType.color,
                'player'
            );
            player.maxSpeed *= carType.speed;
            player.turnSpeed *= carType.handling;
            
            // Reset game state
            enemies = [];
            powerups = [];
            obstacles = [];
            gameState.score = 0;
            gameState.distance = 0;
            gameState.speed = 0;
            gameState.time = 0;
            gameState.dayNightCycle = 0;
            
            // Set weather
            const weathers = ['clear', 'rain', 'fog', 'night'];
            gameState.weather = weathers[Math.floor(Math.random() * weathers.length)];
            updateWeather();
            
            // Hide menus
            hideAllMenus();
            
            // Start game loop
            gameState.isPlaying = true;
            gameLoop();
        }

        // Game Loop
        function gameLoop(currentTime = 0) {
            if (!gameState.isPlaying) return;
            
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            if (!gameState.isPaused) {
                update(deltaTime);
            }
            
            render();
            
            requestAnimationFrame(gameLoop);
        }

        // Update Game Logic
        function update(deltaTime) {
            frameCount++;
            
            // Update player
            player.update();
            gameState.speed = player.speed;
            
            // Update distance and score
            gameState.distance += player.speed * 0.01;
            gameState.score += Math.floor(player.speed * 0.1);
            
            // Update time
            gameState.time += deltaTime / 1000;
            
            // Update day/night cycle
            gameState.dayNightCycle = (gameState.dayNightCycle + 0.0001) % 1;
            
            // Update background
            background.update(player.speed);
            
            // Update road
            road.update(player.speed);
            
            // Spawn enemies
            if (frameCount % getEnemySpawnRate() === 0) {
                spawnEnemy();
            }
            
            // Update enemies
            enemies = enemies.filter(enemy => {
                enemy.update(player);
                
                // Check collision with player
                if (checkCollision(player, enemy)) {
                    if (player.shield) {
                        player.shield = false;
                        enemy.y = -100;
                        particleSystem.createExplosion(enemy.x, enemy.y, '#00ffff');
                        gameState.score += 500;
                    } else {
                        player.health -= 20;
                        player.addSparks();
                        particleSystem.createExplosion(player.x, player.y);
                        
                        if (player.health <= 0) {
                            gameOver();
                        }
                    }
                }
                
                return enemy.y < canvas.height + 100;
            });
            
            // Spawn power-ups
            if (frameCount % CONFIG.powerupSpawnRate === 0) {
                spawnPowerUp();
            }
            
            // Update power-ups
            powerups = powerups.filter(powerup => {
                powerup.update();
                
                // Check collection
                if (checkCollision(player, powerup)) {
                    collectPowerUp(powerup);
                    return false;
                }
                
                // Magnet effect
                if (player.magnet) {
                    const dx = player.x - powerup.x;
                    const dy = player.y - powerup.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < 150) {
                        powerup.x += dx * 0.1;
                        powerup.y += dy * 0.1;
                    }
                }
                
                return powerup.y < canvas.height + 50;
            });
            
            // Spawn obstacles
            if (frameCount % CONFIG.obstacleSpawnRate === 0) {
                spawnObstacle();
            }
            
            // Update obstacles
            obstacles = obstacles.filter(obstacle => {
                obstacle.update();
                
                // Check collision
                if (checkCollision(player, obstacle)) {
                    if (!player.shield) {
                        player.health -= 10;
                        player.speed *= 0.5;
                        player.addSparks();
                        
                        if (player.health <= 0) {
                            gameOver();
                        }
                    }
                    return false;
                }
                
                return obstacle.y < canvas.height + 50;
            });
            
            // Update particle system
            particleSystem.update();
            
            // Update HUD
            updateHUD();
            
            // Check achievements
            checkAchievements();
            
            // Update minimap
            updateMinimap();
            
            // Mode-specific updates
            if (gameState.currentMode === 'timetrial') {
                if (gameState.time > 60) {
                    gameOver();
                }
            } else if (gameState.currentMode === 'levels') {
                if (gameState.distance > gameState.level * 1000) {
                    levelUp();
                }
            }
        }

        // Render Game
        function render() {
            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Apply speed blur effect
            if (player.speed > 200) {
                ctx.filter = `blur(${(player.speed - 200) * 0.05}px)`;
            }
            
            // Draw background
            background.draw(ctx);
            
            // Draw road
            road.draw(ctx);
            
            // Remove filter for game objects
            ctx.filter = 'none';
            
            // Draw obstacles
            obstacles.forEach(obstacle => obstacle.draw(ctx));
            
            // Draw power-ups
            powerups.forEach(powerup => powerup.draw(ctx));
            
            // Draw enemies
            enemies.forEach(enemy => enemy.draw(ctx));
            
            // Draw player
            player.draw(ctx);
            
            // Draw particles
            particleSystem.draw(ctx);
            
            // Apply weather effects
            if (gameState.weather === 'rain' || gameState.dayNightCycle > 0.5) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        }

        // Collision Detection
        function checkCollision(obj1, obj2) {
            return obj1.x - obj1.width / 2 < obj2.x + obj2.width / 2 &&
                   obj1.x + obj1.width / 2 > obj2.x - obj2.width / 2 &&
                   obj1.y - obj1.height / 2 < obj2.y + obj2.height / 2 &&
                   obj1.y + obj1.height / 2 > obj2.y - obj2.height / 2;
        }

        // Spawn Functions
        function spawnEnemy() {
            const lane = Math.floor(Math.random() * 4);
            const x = (canvas.width - CONFIG.roadWidth) / 2 + lane * CONFIG.laneWidth + CONFIG.laneWidth / 2;
            const y = -100;
            
            enemies.push(new EnemyCar(x, y, lane));
        }

        function spawnPowerUp() {
            const types = ['boost', 'shield', 'magnet', 'slow', 'points'];
            const type = types[Math.floor(Math.random() * types.length)];
            const lane = Math.floor(Math.random() * 4);
            const x = (canvas.width - CONFIG.roadWidth) / 2 + lane * CONFIG.laneWidth + CONFIG.laneWidth / 2;
            const y = -50;
            
            powerups.push(new PowerUp(x, y, type));
        }

        function spawnObstacle() {
            const types = ['cone', 'barrier'];
            const type = types[Math.floor(Math.random() * types.length)];
            const lane = Math.floor(Math.random() * 4);
            const x = (canvas.width - CONFIG.roadWidth) / 2 + lane * CONFIG.laneWidth + CONFIG.laneWidth / 2;
            const y = -50;
            
            obstacles.push(new Obstacle(x, y, type));
        }

        // Power-up Collection
        function collectPowerUp(powerup) {
            switch (powerup.type) {
                case 'boost':
                    player.boost = true;
                    setTimeout(() => player.boost = false, 5000);
                    showPowerupIndicator(1, '⚡');
                    break;
                case 'shield':
                    player.shield = true;
                    setTimeout(() => player.shield = false, 8000);
                    showPowerupIndicator(2, '🛡️');
                    break;
                case 'magnet':
                    player.magnet = true;
                    setTimeout(() => player.magnet = false, 6000);
                    showPowerupIndicator(3, '🧲');
                    break;
                case 'slow':
                    enemies.forEach(enemy => enemy.speed *= 0.5);
                    setTimeout(() => enemies.forEach(enemy => enemy.speed *= 2), 3000);
                    break;
                case 'points':
                    gameState.score += 1000;
                    break;
            }
            
            particleSystem.createExplosion(powerup.x, powerup.y, powerup.colors[powerup.type]);
        }

        // Show Power-up Indicator
        function showPowerupIndicator(slot, icon) {
            const indicator = document.getElementById(`powerup${slot}`);
            indicator.textContent = icon;
            indicator.classList.add('active');
            
            setTimeout(() => {
                indicator.classList.remove('active');
                indicator.textContent = '';
            }, 5000);
        }

        // Get Enemy Spawn Rate based on difficulty
        function getEnemySpawnRate() {
            const rates = {
                easy: 80,
                normal: 60,
                hard: 40,
                extreme: 20
            };
            return rates[gameState.difficulty];
        }

        // Update HUD
        function updateHUD() {
            document.querySelector('.speedometer').textContent = `${Math.floor(player.speed)} km/h`;
            document.querySelector('.score').textContent = `Score: ${gameState.score}`;
            document.querySelector('.distance').textContent = `Distance: ${Math.floor(gameState.distance)}m`;
            document.getElementById('gameMode').textContent = `Mode: ${gameState.currentMode}`;
        }

        // Update Minimap
        function updateMinimap() {
            minimapCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            minimapCtx.fillRect(0, 0, minimap.width, minimap.height);
            
            const scale = CONFIG.minimapScale;
            
            // Draw road on minimap
            minimapCtx.fillStyle = '#444';
            minimapCtx.fillRect(
                (minimap.width - CONFIG.roadWidth * scale) / 2,
                0,
                CONFIG.roadWidth * scale,
                minimap.height
            );
            
            // Draw player
            minimapCtx.fillStyle = '#00ff00';
            minimapCtx.fillRect(
                player.x * scale - 2,
                minimap.height - 20,
                4,
                4
            );
            
            // Draw enemies
            minimapCtx.fillStyle = '#ff0000';
            enemies.forEach(enemy => {
                if (enemy.y > 0 && enemy.y < canvas.height) {
                    minimapCtx.fillRect(
                        enemy.x * scale - 2,
                        enemy.y * scale,
                        4,
                        4
                    );
                }
            });
            
            // Draw power-ups
            minimapCtx.fillStyle = '#ffff00';
            powerups.forEach(powerup => {
                if (powerup.y > 0 && powerup.y < canvas.height) {
                    minimapCtx.fillRect(
                        powerup.x * scale - 1,
                        powerup.y * scale,
                        2,
                        2
                    );
                }
            });
        }

        // Weather System
        function updateWeather() {
            const overlay = document.getElementById('weatherOverlay');
            overlay.className = 'weatherOverlay';
            
            if (gameState.weather === 'rain') {
                overlay.classList.add('rain');
            } else if (gameState.weather === 'fog') {
                overlay.classList.add('fog');
            }
        }

        // Achievement System
        function checkAchievements() {
            const achievements = [
                { id: 'speed_demon', name: 'Speed Demon', condition: player.speed >= 300 },
                { id: 'distance_master', name: 'Distance Master', condition: gameState.distance >= 10000 },
                { id: 'score_champion', name: 'Score Champion', condition: gameState.score >= 50000 },
                { id: 'survivor', name: 'Survivor', condition: gameState.time >= 300 },
                { id: 'perfect_driver', name: 'Perfect Driver', condition: gameState.distance >= 5000 && player.health === 100 }
            ];
            
            achievements.forEach(achievement => {
                if (achievement.condition && !gameState.achievements.includes(achievement.id)) {
                    unlockAchievement(achievement);
                }
            });
        }

        function unlockAchievement(achievement) {
            gameState.achievements.push(achievement.id);
            showAchievement(achievement.name);
            gameState.score += 5000;
        }

        function showAchievement(name) {
            const achievementDiv = document.getElementById('achievement');
            document.getElementById('achievementText').textContent = name;
            achievementDiv.classList.add('show');
            
            setTimeout(() => {
                achievementDiv.classList.remove('show');
            }, 3000);
        }

        // Game Over
        function gameOver() {
            gameState.isPlaying = false;
            
            // Update high score
            if (gameState.score > gameState.highScores[gameState.currentMode]) {
                gameState.highScores[gameState.currentMode] = gameState.score;
                saveGameData();
            }
            
            // Show game over screen
            const gameOverDiv = document.getElementById('gameOver');
            const finalStats = document.getElementById('finalStats');
            
            finalStats.innerHTML = `
                <p>Final Score: ${gameState.score}</p>
                <p>Distance: ${Math.floor(gameState.distance)}m</p>
                <p>Time: ${Math.floor(gameState.time)}s</p>
                <p>Top Speed: ${Math.floor(player.speed)} km/h</p>
                <p>High Score: ${gameState.highScores[gameState.currentMode]}</p>
            `;
            
            gameOverDiv.style.display = 'block';
        }

        // Level Up
        function levelUp() {
            gameState.level++;
            player.health = 100;
            showAchievement(`Level ${gameState.level} Reached!`);
            
            // Increase difficulty
            if (gameState.difficulty === 'easy' && gameState.level > 3) {
                gameState.difficulty = 'normal';
            } else if (gameState.difficulty === 'normal' && gameState.level > 6) {
                gameState.difficulty = 'hard';
            } else if (gameState.difficulty === 'hard' && gameState.level > 10) {
                gameState.difficulty = 'extreme';
            }
        }

        // Menu Functions
        function hideAllMenus() {
            document.querySelectorAll('.menu').forEach(menu => {
                menu.classList.add('hidden');
            });
            document.getElementById('pauseMenu').style.display = 'none';
            document.getElementById('gameOver').style.display = 'none';
        }

        function showGameModeSelection() {
            hideAllMenus();
            document.getElementById('gameModeMenu').classList.remove('hidden');
        }

        function showCarSelection() {
            hideAllMenus();
            const carOptions = document.getElementById('carOptions');
            carOptions.innerHTML = '';
            
            carTypes.forEach((car, index) => {
                const option = document.createElement('div');
                option.className = 'carOption' + (index === gameState.selectedCar ? ' selected' : '');
                option.innerHTML = `
                    <div class="carPreview" style="background: ${car.color}"></div>
                    <h3>${car.name}</h3>
                    <p>Speed: ${car.speed}x</p>
                    <p>Handling: ${car.handling}x</p>
                `;
                option.onclick = () => selectCar(index);
                carOptions.appendChild(option);
            });
            
            document.getElementById('carSelectionMenu').classList.remove('hidden');
        }

        function selectCar(index) {
            gameState.selectedCar = index;
            showCarSelection();
        }

        function showSettings() {
            hideAllMenus();
            document.getElementById('settingsMenu').classList.remove('hidden');
            
            // Load current settings
            document.getElementById('soundVolume').value = gameState.soundVolume;
            document.getElementById('musicVolume').value = gameState.musicVolume;
            document.getElementById('difficulty').value = gameState.difficulty;
            document.getElementById('graphics').value = gameState.graphicsQuality;
        }

        function saveSettings() {
            gameState.soundVolume = document.getElementById('soundVolume').value;
            gameState.musicVolume = document.getElementById('musicVolume').value;
            gameState.difficulty = document.getElementById('difficulty').value;
            gameState.graphicsQuality = document.getElementById('graphics').value;
            
            saveGameData();
            backToMenu();
        }

        function showLeaderboard() {
            hideAllMenus();
            // Create leaderboard display
            const leaderboard = document.createElement('div');
            leaderboard.className = 'menu';
            leaderboard.innerHTML = `
                <h1>Leaderboard</h1>
                <div style="margin: 20px 0;">
                    <h3>Endless Mode: ${gameState.highScores.endless}</h3>
                    <h3>Time Trial: ${gameState.highScores.timetrial}</h3>
                    <h3>Level Mode: ${gameState.highScores.levels}</h3>
                    <h3>Police Chase: ${gameState.highScores.police}</h3>
                </div>
                <button class="menuButton" onclick="backToMenu()">Back</button>
            `;
            document.getElementById('gameContainer').appendChild(leaderboard);
        }

        function showTutorial() {
            hideAllMenus();
            document.getElementById('tutorial').style.display = 'block';
            setTimeout(() => {
                document.getElementById('tutorial').style.display = 'none';
                backToMenu();
            }, 5000);
        }

        function backToMenu() {
            hideAllMenus();
            document.getElementById('mainMenu').classList.remove('hidden');
            
            // Remove any dynamically created menus
            const leaderboard = document.querySelector('.menu:last-child');
            if (leaderboard && leaderboard.id !== 'mainMenu') {
                leaderboard.remove();
            }
        }

        // Game Control Functions
        function startGame(mode) {
            gameState.currentMode = mode;
            hideAllMenus();
            initGame();
        }

        function togglePause() {
            gameState.isPaused = !gameState.isPaused;
            document.getElementById('pauseMenu').style.display = gameState.isPaused ? 'block' : 'none';
        }

        function resumeGame() {
            gameState.isPaused = false;
            document.getElementById('pauseMenu').style.display = 'none';
        }

        function restartGame() {
            document.getElementById('gameOver').style.display = 'none';
            initGame();
        }

        // Save/Load Game Data
        function saveGameData() {
            const data = {
                highScores: gameState.highScores,
                achievements: gameState.achievements,
                selectedCar: gameState.selectedCar,
                settings: {
                    difficulty: gameState.difficulty,
                    graphicsQuality: gameState.graphicsQuality,
                    soundVolume: gameState.soundVolume,
                    musicVolume: gameState.musicVolume
                }
            };
            localStorage.setItem('speedRacerPro', JSON.stringify(data));
        }

        function loadGameData() {
            const saved = localStorage.getItem('speedRacerPro');
            if (saved) {
                const data = JSON.parse(saved);
                gameState.highScores = data.highScores || gameState.highScores;
                gameState.achievements = data.achievements || [];
                gameState.selectedCar = data.selectedCar || 0;
                
                if (data.settings) {
                    gameState.difficulty = data.settings.difficulty;
                    gameState.graphicsQuality = data.settings.graphicsQuality;
                    gameState.soundVolume = data.settings.soundVolume;
                    gameState.musicVolume = data.settings.musicVolume;
                }
            }
        }

        // Loading Screen
        function showLoadingScreen() {
            const loadingScreen = document.getElementById('loadingScreen');
            const progress = document.getElementById('loadingProgress');
            
            let loadProgress = 0;
            const loadingInterval = setInterval(() => {
                loadProgress += 10;
                progress.style.width = loadProgress + '%';
                
                if (loadProgress >= 100) {
                    clearInterval(loadingInterval);
                    loadingScreen.style.display = 'none';
                    loadGameData();
                }
            }, 100);
        }

        // Initialize Game on Load
        window.onload = () => {
            showLoadingScreen();
        };

        // Prevent context menu on right click
        canvas.addEventListener('contextmenu', (e) => e.preventDefault());
    </script>
</body>
</html>